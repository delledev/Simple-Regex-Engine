import { Token, TokenType } from "./token";
import * as AST from "./ast";
import { Tokenize } from "./lexer";

// Parser class for parsing regular expressions into abstract syntax trees (AST)
export class Parser {
  private regex: string; // The input regular expression string
  private tokens: Token[]; // Array of tokens generated by the lexer
  private tokensUntouched: Token[]; // Copy of the original tokens array for reference
  private alphabet: string[]; // The alphabet for character verification

  // Constructor that takes a regular expression string and an alphabet
  constructor(regex: string, alphabet: string[]) {
    this.regex = regex;
    this.tokens = Tokenize(regex); // Tokenize the input regular expression
    this.tokensUntouched = [...this.tokens]; // Create a copy of the original tokens array
    this.alphabet = alphabet; // Set the alphabet for character verification
  }

  // Method to parse the regular expression into an abstract syntax tree (AST)
  public Parse(): { ast: AST.Regex; tokens: Token[] } | string {
    let res = this.parseNodes();
    if (res.success) {
      const regexnode: AST.Regex = {
        type: "regex",
        body: res.nodes,
      };
      return { ast: regexnode, tokens: this.tokensUntouched };
    } else {
      return res?.message;
    }
  }

  // Helper method to consume the next token from the tokens array
  private eat() {
    let prevToken = this.tokens.shift();
    return prevToken as Token;
  }

  // Helper method to create a disjunction node
  private disjunctionNode(
    leftNode: AST.Node,
    rightNode: AST.Node,
  ): AST.DisjunctionNode {
    return {
      type: "Disjunction",
      left: leftNode,
      right: rightNode,
      quantifier: null,
    };
  }

  // Helper method to verify if a character token is in the alphabet
  private verifyCharacterToken(str: string): boolean {
    if (this.alphabet.length == 0) {
      return true;
    }

    const sortedWordArray = this.alphabet.sort((a, b) => b.length - a.length);

    while (str.length > 0) {
      let found = false;

      for (const word of sortedWordArray) {
        if (str.startsWith(word)) {
          found = true;
          str = str.slice(word.length);
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }

  // Main method to parse nodes of the abstract syntax tree (AST)
  private parseNodes(): {
    nodes: AST.Node[];
    success: boolean;
    message: string;
  } {
    let capturingMode = false;
    let branches: AST.Node[] = new Array<AST.Node>();
    let nodes: AST.Node[] = new Array<AST.Node>();
    let leftNode: AST.Node | undefined;
    let rightNode: AST.Node | undefined;

    // Loop through the tokens array
    while (this.tokens.length > 0) {
      let currentToken = this.eat();

      // Update capturing mode based on opening and closing parentheses
      if (currentToken.value == "(") {
        capturingMode = true;
      } else if (currentToken.value == ")") {
        capturingMode = false;
      }

      switch (currentToken.type) {
        case TokenType.RegexEnd: {
          branches.forEach((branch) => nodes.push(branch));
          break;
        }
        case TokenType.GroupEnd: {
          // Create a GroupNode when encountering the end of a group
          let GroupNode: AST.GroupNode = {
            type: "group",
            kind: "simple",
            expression: branches,
            quantifier: null,
          };

          // Add the GroupNode to the nodes array
          if (branches.length > 0) {
            branches = new Array<AST.Node>();
            if (leftNode) {
              nodes.push(this.disjunctionNode(leftNode, GroupNode));
              leftNode = undefined;
            } else {
              nodes.push(GroupNode);
            }
          }
          break;
        }
        case TokenType.GroupStart: {
          // Add branches to nodes array when encountering the start of a group
          if (branches.length > 0) {
            branches.forEach((b) => nodes.push(b));
            branches = new Array<AST.Node>();
          }
          break;
        }
        case TokenType.GreedyOperator: {
          // Add a '*' quantifier to the last branch or node
          if (branches.length > 0) {
            let branch = branches[branches.length - 1];
            let q: AST.Quantifier = {
              type: "Quantifier",
              kind: "*",
              greedy: true,
            };

            if (branch.type == "Disjunction") {
              branch.right.quantifier = q;
            } else {
              branches[branches.length - 1].quantifier = q;
            }
          } else if (nodes.length > 0) {
            nodes[nodes.length - 1].quantifier = {
              type: "Quantifier",
              kind: "*",
              greedy: true,
            };
          }
          break;
        }
        case TokenType.Char: {
          // Process character tokens and create StringNodes
          let tokenString = currentToken.value;
          let verify = this.verifyCharacterToken(currentToken.value);

          // Check if the character token is in the alphabet
          if (!verify) {
            return {
              nodes,
              success: false,
              message: `Unknown token ${currentToken.value} at ${currentToken.loc}.`,
            };
          }

          // Split the character token into individual characters and create StringNodes
          tokenString.split("").forEach((char) => {
            let textNode: AST.StringNode = {
              type: "character",
              kind: "string",
              value: char,
              quantifier: null,
            };

            // Add the StringNode to the branches array or nodes array
            if (leftNode && !capturingMode) {
              branches.push(this.disjunctionNode(leftNode, textNode));
              leftNode = undefined;
            } else {
              branches.push(textNode);
            }
          });
          break;
        }
        case TokenType.OrOperator: {
          // Set the leftNode when encountering the '|' operator
          if (branches.length > 0) {
            leftNode = branches.pop();
          } else if (nodes.length > 0) {
            leftNode = nodes.pop();
          }
          break;
        }
      }
    }

    // Check for unclosed capturing group
    if (capturingMode) {
      return {
        nodes,
        success: false,
        message: "Unclosed capturing group detected!",
      };
    }

    return { nodes, success: true, message: "" };
  }
}
